//! # Capability Space (CSpace) — Core Security Model
//!
//! This module implements the **capability-based security model** inspired by seL4.
//!
//! ## What is a Capability?
//! A capability is an unforgeable "key" that grants a specific permission to a
//! specific resource. Think of it like a file descriptor in Unix, but more general:
//!
//! | Capability Type | Resource | Allowed Operations |
//! |:---|:---|:---|
//! | `MemoryCap`     | A physical memory frame | Read, Write, Map |
//! | `EndpointCap`   | An IPC endpoint | Send, Receive |
//! | `ThreadCap`     | A thread/process | Start, Stop, Configure |
//! | `DeviceCap`     | A hardware device (e.g., serial port) | Read, Write |
//!
//! ## Why Capabilities?
//! In traditional OS security (like Linux), access control is based on
//! "who you are" (user ID, root). In a capability system, access is based on
//! "what keys you hold." This is fundamentally more secure:
//! - **No ambient authority**: A process can't access anything unless explicitly given a key.
//! - **Principle of least privilege**: Each process gets only the keys it needs.
//! - **Unforgeable**: Keys are managed by the kernel — user code can't create them.
//!
//! ## Current Implementation
//! This is the initial skeleton. It defines the data structures and basic
//! operations. The kernel will use this to control all resource access.

use core::sync::atomic::{AtomicU64, Ordering};

/// Unique identifier for a capability. Generated by the kernel and never reused.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct CapabilityId(u64);

/// Global counter for generating unique capability IDs.
static NEXT_CAP_ID: AtomicU64 = AtomicU64::new(1);

impl CapabilityId {
    /// Generate a new unique capability ID.
    ///
    /// This is atomic and safe to call from interrupt handlers.
    pub fn new() -> Self {
        CapabilityId(NEXT_CAP_ID.fetch_add(1, Ordering::Relaxed))
    }

    /// Returns the raw numeric ID (for debugging/logging).
    pub fn as_u64(&self) -> u64 {
        self.0
    }
}

/// The type of resource a capability grants access to.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CapabilityType {
    /// Access to a physical memory frame (for mapping into address spaces).
    Memory,
    /// Access to an IPC endpoint (for sending/receiving messages).
    Endpoint,
    /// Access to a thread/task (for lifecycle management).
    Thread,
    /// Access to a hardware device (for I/O operations).
    Device,
    /// A "null" capability — placeholder for empty CSpace slots.
    Null,
}

/// The permissions granted by a capability.
///
/// Permissions are stored as a bitmask for efficient checking.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Permissions(u32);

impl Permissions {
    pub const NONE: Self = Permissions(0);
    pub const READ: Self = Permissions(1 << 0);
    pub const WRITE: Self = Permissions(1 << 1);
    pub const EXECUTE: Self = Permissions(1 << 2);
    pub const GRANT: Self = Permissions(1 << 3); // Can delegate this capability to others

    /// Combine two permission sets.
    pub const fn union(self, other: Self) -> Self {
        Permissions(self.0 | other.0)
    }

    /// Check if this permission set includes another.
    pub const fn contains(self, other: Self) -> bool {
        (self.0 & other.0) == other.0
    }

    /// Returns a permission set with all permissions enabled.
    pub const fn all() -> Self {
        Permissions(0b1111)
    }
}

/// A single capability — an unforgeable key to a resource.
#[derive(Debug, Clone)]
pub struct Capability {
    /// Unique ID of this capability.
    pub id: CapabilityId,
    /// What type of resource this grants access to.
    pub cap_type: CapabilityType,
    /// What operations are allowed.
    pub permissions: Permissions,
    /// Kernel-internal identifier of the resource (e.g., frame number, endpoint ID).
    pub resource_id: u64,
}

/// The Capability Space — a per-process table of capabilities.
///
/// Each process (or "protection domain") has its own CSpace.
/// The kernel is the only entity that can create, copy, or revoke capabilities.
///
/// Currently uses a fixed-size array. A real implementation would use a
/// radix tree or similar structure for scalability.
pub const CSPACE_SIZE: usize = 64;

pub struct CSpace {
    /// The slots in this capability space.
    slots: [Option<Capability>; CSPACE_SIZE],
    /// Number of capabilities currently stored.
    count: usize,
}

impl CSpace {
    /// Create a new, empty capability space.
    pub const fn new() -> Self {
        // Initialize all slots to None using a const-compatible approach.
        const EMPTY: Option<Capability> = None;
        CSpace {
            slots: [EMPTY; CSPACE_SIZE],
            count: 0,
        }
    }

    /// Insert a capability into the first available slot.
    ///
    /// Returns the slot index on success, or `None` if the CSpace is full.
    pub fn insert(&mut self, cap: Capability) -> Option<usize> {
        for (i, slot) in self.slots.iter_mut().enumerate() {
            if slot.is_none() {
                *slot = Some(cap);
                self.count += 1;
                return Some(i);
            }
        }
        None // CSpace is full
    }

    /// Look up a capability by slot index.
    pub fn get(&self, slot: usize) -> Option<&Capability> {
        self.slots.get(slot)?.as_ref()
    }

    /// Revoke (remove) a capability from a slot.
    ///
    /// Returns the removed capability, or `None` if the slot was empty.
    pub fn revoke(&mut self, slot: usize) -> Option<Capability> {
        if slot < CSPACE_SIZE {
            let cap = self.slots[slot].take();
            if cap.is_some() {
                self.count -= 1;
            }
            cap
        } else {
            None
        }
    }

    /// Check if a slot holds a capability with the required permissions.
    ///
    /// This is the core access-control check. Every resource access in the
    /// kernel goes through this method.
    pub fn check_permission(&self, slot: usize, required: Permissions) -> bool {
        match self.get(slot) {
            Some(cap) => cap.permissions.contains(required),
            None => false,
        }
    }

    /// Returns the number of capabilities in this CSpace.
    pub fn len(&self) -> usize {
        self.count
    }

    /// Returns true if the CSpace has no capabilities.
    pub fn is_empty(&self) -> bool {
        self.count == 0
    }
}
